---
title: "GAMM"
author: "Sarah Popov"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
library(ggplot2)
library(formatR)

knitr::opts_chunk$set(echo = FALSE,
                      warning = FALSE, 
                      message = FALSE,
                      tidy.opts = list(width.cutoff = 60), 
                      tidy = TRUE)

# Color palette (using blue & yellow from wesanderson Zissou1 palette)
pal <- c(rgb(86, 152, 175, maxColorValue = 255), rgb(229, 205, 79, maxColorValue = 255))

# Source the data file, which connects to the bppeeps database and then queries and processes the data
# This will produce two datasets: 
# 1) dat [counts + environmental covariates]
# 2) sr [daily species ratios]
source(here::here("models", "prepare_dat.R"))
source(here::here("models", "binomial_sr.R"))
```

```{r merge sr results in, include = FALSE}
# Add predicted wesa ratio generated above to the dat dataset
dat <- merge(dat, yrs[,c("year", "julian_day", "predicted_ratio")], 
             by = c("year", "julian_day"))

# Scale and log-transform variables of interest
dat$predicted_wesa <- round(dat$final_count * dat$predicted_ratio, 0)
dat$predicted_dunl <- dat$final_count - dat$predicted_wesa
dat$log_wesa <- log(dat$predicted_wesa + 1)
dat$log_dunl <- log(dat$predicted_dunl + 1)
dat$year_c <- scale(as.numeric(dat$year))

# Remove records with NA in important environmental covariates
dat <- dat[!is.na(dat$flow) & !is.na(dat$total_precip),]

# Proportion of zeroes
dat_p0 <- sum(dat$predicted_wesa == 0) / length(dat$predicted_wesa)
```

```{r aggregate by NS, include=FALSE}
dat3 <- sqldf::sqldf("select year, 
                      survey_date, 
                      julian_day, 
                      min(start_time) as start_time, 
                      n_s, 
                      sum(final_count) as final_count, 
                      sum(predicted_wesa) as predicted_wesa, 
                      sum(predicted_dunl) as predicted_dunl, 
                      p_wesa, 
                      predicted_ratio, 
                      avg(raptor_count) as raptor_count, 
                      tide,
                      elev_min, 
                      elev_max, 
                      elev_median, 
                      elev_mean, 
                      elev_range, 
                      flow, 
                      total_precip, 
                      mean_temp, 
                      u, 
                      v, 
                      windspd, 
                      wind_deg 
                      from dat 
                      group by survey_date, n_s;") %>%
  dplyr::mutate(dos = scale(julian_day),
                log_wesa = log(predicted_wesa + 1),
                log_dunl = log(predicted_dunl + 1),
                year_n = as.numeric(year),
                year_c = scale(year_n)) %>%
  dplyr::select(year, survey_date, julian_day, dos, start_time, n_s,
                final_count, predicted_wesa, predicted_dunl, log_wesa, 
                log_dunl, dplyr::everything())

# Proportion of zeroes
dat3_p0 <- sum(dat3$predicted_wesa == 0) / length(dat3$predicted_wesa)
```

# WESA GAM ZIP + ZINB

From the `glmmTMB` explorations, two things jumped out: 
1) The negative binomial distribution fits the data best.
2) A non-linear approach might fit the data better.


```{r wesa gam base models, include=TRUE}
# Base script by Gavin Simpson
# https://fromthebottomoftheheap.net/2017/05/04/compare-mgcv-with-glmmtmb/
# https://gist.github.com/gavinsimpson/8a0f0e072b095295cf5f7af2762e05a7

library("mgcv")
library("glmmTMB")

## Poisson Models
pgam0 <- gam(predicted_wesa ~ n_s + year_c + s(dos) + s(year, bs = "re"), data = dat3, family = poisson, method = "ML")
pgam1 <- gam(predicted_wesa ~ n_s + s(flow) + year_c + s(dos) + s(year, bs = "re"), data = dat3, family = poisson, method = "ML")
pgam2 <- gam(predicted_wesa ~ n_s + s(flow) + n_s:flow + year_c + s(dos) + s(year, bs = "re"), data = dat3, family = poisson, method = "ML")

pm0 <- glmmTMB(predicted_wesa ~ n_s + year_c + I(dos^2) + (1|year), data = dat3, family = poisson)
pm1 <- glmmTMB(predicted_wesa ~ n_s + flow + year_c + I(dos^2) + (1|year), data = dat3, family = poisson)
pm2 <- glmmTMB(predicted_wesa ~ n_s * flow + year_c + I(dos^2) + (1|year), data = dat3, family = poisson)

AIC(pgam0, pgam1, pgam2)
AIC(pm0, pm1, pm2)

## Negative binomial models
nbgam0 <- gam(predicted_wesa ~ n_s + year_c + s(dos) + s(year, bs = "re"), data = dat3, family = nb, method = "ML")
nbgam1 <- gam(predicted_wesa ~ n_s + s(flow) + year_c + s(dos) + s(year, bs = "re"), data = dat3, family = nb, method = "ML")
nbgam2 <- gam(predicted_wesa ~ n_s + s(flow) + n_s:flow + year_c + s(dos) + s(year, bs = "re"), data = dat3, family = nb, method = "ML")

nbm0 <- glmmTMB(predicted_wesa ~ n_s + year_c + I(dos^2) + (1|year), data = dat3, family = nbinom2)
nbm1 <- glmmTMB(predicted_wesa ~ n_s + flow + year_c + I(dos^2) + (1|year), data = dat3, family = nbinom2)
nbm2 <- glmmTMB(predicted_wesa ~ n_s * flow + year_c + I(dos^2) + (1|year), data = dat3, family = nbinom2)

AIC(nbgam0, nbgam1, nbgam2)
AIC(nbm0, nbm1, nbm2)

## Zero-inflated Poisson
## mgcv's ziplss can only fit using REML
zipgam0 <- gam(list(predicted_wesa ~ n_s + year_c + s(dos) + s(year, bs = "re"), ~ n_s),
               data = dat3, family = ziplss, method = "REML")
zipgam1 <- gam(list(predicted_wesa ~ n_s + s(flow) + year_c + s(dos) + s(year, bs = "re"), ~ n_s),
               data = dat3, family = ziplss, method = "REML")
zipgam2 <- gam(list(predicted_wesa ~ n_s + s(flow) + n_s:flow + year_c + s(dos) + s(year, bs = "re"), ~ n_s + flow),
               data = dat3, family = ziplss, method = "REML")
zipgam3 <- gam(list(predicted_wesa ~ n_s + year_c + s(dos) + s(year, bs = "re"), ~ n_s * flow),
               data = dat3, family = ziplss, method = "REML")
## check the things converged
zipgam0$outer.info
zipgam1$outer.info
zipgam2$outer.info
zipgam3$outer.info

zipm0 <- glmmTMB(predicted_wesa ~ n_s + year_c + I(dos^2) + (1|year), zi = ~ n_s, data = dat3, family = poisson)
zipm1 <- glmmTMB(predicted_wesa ~ n_s + flow + year_c + I(dos^2) + (1|year), zi = ~ n_s, data = dat3, family = poisson)
zipm2 <- glmmTMB(predicted_wesa ~ n_s + flow + year_c + I(dos^2) + (1|year), zi = ~ n_s + flow, data = dat3, family = poisson)
zipm3 <- glmmTMB(predicted_wesa ~ n_s * flow + year_c + I(dos^2) + (1|year), zi = ~ n_s * flow, data = dat3, family = poisson)

AIC(zipgam0, zipgam1, zipgam2, zipgam3)
AIC(zipm0, zipm1, zipm2, zipm3)

# Compare them all
bbmle::AICtab(pgam0, pgam1, pgam2, pm0, pm1, pm2, nbgam0, nbgam1, nbgam2, nbm0, nbm1, nbm2, zipgam0, zipgam1, zipgam2, zipm0, zipm1, zipm2)
```

```{r}
full_gam <- gam(predicted_wesa ~ n_s + s(flow) + year_c + s(mean_temp) + s(elev_range) + tide + s(total_precip) + s(u) + raptor_count + s(dos, bs = "re") + s(year, bs = "re"),
                   dat = dat3,
                   family = nb)
```

